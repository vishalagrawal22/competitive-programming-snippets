{
  "Competitive Boiler Plate": {
    "prefix": "competitive",
    "description": "Competitive Programming Boiler Plate",
    "body": [
      "#include \"bits/stdc++.h\"",
      "",
      "using big = long long;",
      "using ld = long double;",
      "const char nl = '\\n';",
      "#define all(x) (x).begin(), (x).end()",
      "#define precise(x) \\",
      "    fixed << setprecision(x)",
      "#define set_bit_count(x) __builtin_popcountll(x)",
      "#ifdef Haunted_Knight",
      "#define msg(statement) cerr << statement << endl",
      "#define dbg(var) cerr << (#var) << \": \" << var << endl",
      "#else",
      "#define msg(statement)",
      "#define dbg(var)",
      "#endif",
      "",
      "using namespace std;",
      "",
      "template <typename T>",
      "using min_heap = priority_queue<T, vector<T>, greater<T>>;",
      "template <typename T>",
      "using max_heap = priority_queue<T>;",
      "",
      "template <typename T>",
      "ostream &operator<<(ostream &os, min_heap<T> H)",
      "{",
      "    while (!H.empty())",
      "    {",
      "        os << H.top() << \" \";",
      "        H.pop();",
      "    }",
      "    os << endl;",
      "    return os << \"\";",
      "}",
      "",
      "template <typename T>",
      "ostream &operator<<(ostream &os, max_heap<T> H)",
      "{",
      "    while (!H.empty())",
      "    {",
      "        os << H.top() << \" \";",
      "        H.pop();",
      "    }",
      "    os << endl;",
      "    return os << \"\";",
      "}",
      "",
      "template <typename F, typename S>",
      "ostream &operator<<(ostream &os, pair<F, S> P)",
      "{",
      "    return os << P.first << \" \" << P.second;",
      "}",
      "",
      "template <typename T>",
      "ostream &operator<<(ostream &os, vector<T> arr)",
      "{",
      "    for (int i = 0; i < (int)arr.size(); i++)",
      "    {",
      "        os << arr[i] << \" \";",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "template <typename T>",
      "ostream &operator<<(ostream &os, vector<vector<T>> matrix)",
      "{",
      "    os << endl;",
      "    for (int i = 0; i < (int)matrix.size(); i++)",
      "    {",
      "        for (int j = 0; j < (int)matrix[i].size(); j++)",
      "        {",
      "            os << matrix[i][j] << \" \";",
      "        }",
      "        os << endl;",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "template <typename T>",
      "ostream &operator<<(ostream &os, set<T> S)",
      "{",
      "    for (auto s : S)",
      "    {",
      "        os << s << \" \";",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "template <typename T>",
      "ostream &operator<<(ostream &os, multiset<T> S)",
      "{",
      "    for (auto s : S)",
      "    {",
      "        os << s << \" \";",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "template <typename F, typename S>",
      "ostream &operator<<(ostream &os, map<F, S> M)",
      "{",
      "    os << endl;",
      "    for (auto m : M)",
      "    {",
      "        os << m << endl;",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "template <typename F, typename S>",
      "ostream &operator<<(ostream &os, multimap<F, S> M)",
      "{",
      "    os << endl;",
      "    for (auto m : M)",
      "    {",
      "        os << m << endl;",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "void solve(){",
      "    $0}",
      "",
      "int32_t main()",
      "{",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    // freopen(\"input.in\", \"r\", stdin);",
      "    // freopen(\"output.out\", \"w\", stdout);",
      "    int no_of_testcases = 1;",
      "    // $1cin >> no_of_testcases;",
      "    for (int i = 1; i <= no_of_testcases; i++)",
      "    {",
      "        // cout << \"Case #\" << i << \": \";",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ]
  },
  "PBDS Set boiler plate": {
    "prefix": "pbds",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp> ",
      "#include <ext/pb_ds/tree_policy.hpp> ",
      "using namespace __gnu_pbds; ",
      "  ",
      "#define ordered_set tree<${1:int}, null_type, less<${1:int}>, rb_tree_tag,tree_order_statistics_node_update> "
    ],
    "description": "PBDS Set boiler plate"
  },
  "vector<int> short": {
    "prefix": "vi",
    "body": ["vector<int>"],
    "description": "vector<int> short"
  },
  "vector<vector<int>>": {
    "prefix": "vvi",
    "description": "vector<vector<int>>",
    "body": ["vector<vector<int>>"]
  },
  "pair<int, int>": {
    "prefix": "pii",
    "body": ["pair<int, int>"],
    "description": "pair<int, int>"
  },
  "map<int, int>": {
    "prefix": "mii",
    "body": ["map<int, int>"],
    "description": "map<int, int>"
  },
  "set<int>": {
    "prefix": "si",
    "body": ["set<int>"],
    "description": "set<int>"
  },
  "power function using Binary Exponentiation": {
    "prefix": "pow",
    "description": "power function using Binary Exponentiation",
    "body": [
      "inline int power(int base, int val)",
      "{",
      "    int res = 1;",
      "    while (val > 0)",
      "    {",
      "        if ((val & 1))",
      "        {",
      "            res = res * base;",
      "        }",
      "        base = base * base;",
      "        val = (val >> 1);",
      "    }",
      "    return res;",
      "}"
    ]
  },
  "Extended Euclidean algorithm": {
    "prefix": "euclid",
    "description": "Extended Euclidean algorithm",
    "body": [
      "// Extended Euclidean algorithm",
      "int gcd(int a, int b, int& x, int& y) ",
      "{",
      "    if (b == 0) ",
      "    {",
      "        x = 1;",
      "        y = 0;",
      "        return a;",
      "    }",
      "    int x1, y1;",
      "    int d = gcd(b, a % b, x1, y1);",
      "    x = y1;",
      "    y = x1 - y1 * (a / b);",
      "    return d;",
      "}"
    ]
  },
  "Modular Arithmetic": {
    "prefix": "Arithmetic Modular",
    "description": "Modular Arithmetic",
    "body": [
      "const int mod = 1e9 + 7;",
      "// const int mod = 998244353;",
      "",
      "inline int add(int val1, int val2) ",
      "{",
      "    int ans = val1 + val2;",
      "    if (ans >= mod)",
      "    {",
      "        ans -= mod;",
      "    }",
      "    return ans;",
      "}",
      "",
      "inline int sub(int val1, int val2) ",
      "{",
      "    int ans = val1 - val2;",
      "    if (ans < 0)",
      "    {",
      "        ans += mod;",
      "    }",
      "    return ans;",
      "}",
      "",
      "inline int mult(int val1, int val2) ",
      "{",
      "    int ans = (val1 * 1LL * val2) % mod;",
      "    return ans;",
      "}",
      "",
      "int power(int base, int val)",
      "{",
      "    base = base % mod;",
      "    int res = 1;",
      "    while (val > 0)",
      "    {",
      "        if ((val & 1))",
      "        {",
      "            res = mult(res, base);",
      "        }",
      "        base = mult(base, base);",
      "        val = (val >> 1);",
      "    }",
      "    return res;",
      "}",
      "",
      "int modInverse(int num)",
      "{",
      "    return power(num, mod - 2);",
      "}",
      "",
      "int divide(int val1, int val2)",
      "{",
      "    int val3 = modInverse(val2);",
      "    int ans = mult(val1, val3);",
      "    return ans;",
      "}"
    ]
  },
  "nCr with ModInverse": {
    "prefix": "combinatorics",
    "description": "nCr with ModInverse",
    "body": [
      "#include \"bits/stdc++.h\"",
      "",
      "using big = long long;",
      "using ld = long double;",
      "const char nl = '\\n';",
      "#define all(x) (x).begin(), (x).end()",
      "#define precise(x) \\",
      "    fixed << setprecision(x)",
      "#define set_bit_count(x) __builtin_popcountll(x)",
      "#ifdef Haunted_Knight",
      "#define msg(statement) cerr << statement << endl",
      "#define dbg(var) cerr << (#var) << \": \" << var << endl",
      "#else",
      "#define msg(statement)",
      "#define dbg(var)",
      "#endif",
      "",
      "using namespace std;",
      "",
      "template <typename T>",
      "using min_heap = priority_queue<T, vector<T>, greater<T>>;",
      "template <typename T>",
      "using max_heap = priority_queue<T>;",
      "",
      "template <class T>",
      "ostream &operator<<(ostream &os, min_heap<T> H)",
      "{",
      "    while (!H.empty())",
      "    {",
      "        os << H.top() << \" \";",
      "        H.pop();",
      "    }",
      "    os << endl;",
      "    return os << \"\";",
      "}",
      "",
      "template <class T>",
      "ostream &operator<<(ostream &os, max_heap<T> H)",
      "{",
      "    while (!H.empty())",
      "    {",
      "        os << H.top() << \" \";",
      "        H.pop();",
      "    }",
      "    os << endl;",
      "    return os << \"\";",
      "}",
      "",
      "template <class L, class R>",
      "ostream &operator<<(ostream &os, pair<L, R> P)",
      "{",
      "    return os << P.first << \" \" << P.second;",
      "}",
      "",
      "template <class T>",
      "ostream &operator<<(ostream &os, vector<T> arr)",
      "{",
      "    for (int i = 0; i < (int)arr.size(); i++)",
      "    {",
      "        os << arr[i] << \" \";",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "template <class T>",
      "ostream &operator<<(ostream &os, vector<vector<T>> matrix)",
      "{",
      "    os << endl;",
      "    for (int i = 0; i < (int)matrix.size(); i++)",
      "    {",
      "        for (int j = 0; j < (int)matrix[i].size(); j++)",
      "        {",
      "            os << matrix[i][j] << \" \";",
      "        }",
      "        os << endl;",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "template <class T>",
      "ostream &operator<<(ostream &os, set<T> S)",
      "{",
      "    for (auto s : S)",
      "    {",
      "        os << s << \" \";",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "template <class T>",
      "ostream &operator<<(ostream &os, multiset<T> S)",
      "{",
      "    for (auto s : S)",
      "    {",
      "        os << s << \" \";",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "template <class L, class R>",
      "ostream &operator<<(ostream &os, map<L, R> M)",
      "{",
      "    os << endl;",
      "    for (auto m : M)",
      "    {",
      "        os << m << endl;",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "template <class L, class R>",
      "ostream &operator<<(ostream &os, multimap<L, R> M)",
      "{",
      "    os << endl;",
      "    for (auto m : M)",
      "    {",
      "        os << m << endl;",
      "    }",
      "    return os << \"\";",
      "}",
      "",
      "const int max_n = 2e5;",
      "const int mod = 1e9 + 7;",
      "// const int mod = 998244353;",
      "",
      "inline int add(int val1, int val2)",
      "{",
      "    int ans = val1 + val2;",
      "    if (ans >= mod)",
      "    {",
      "        ans -= mod;",
      "    }",
      "    return ans;",
      "}",
      "",
      "inline int sub(int val1, int val2)",
      "{",
      "    int ans = val1 - val2;",
      "    if (ans < 0)",
      "    {",
      "        ans += mod;",
      "    }",
      "    return ans;",
      "}",
      "",
      "inline int mult(int val1, int val2)",
      "{",
      "    int ans = (val1 * 1LL * val2) % mod;",
      "    return ans;",
      "}",
      "",
      "int power(int base, int val)",
      "{",
      "    base = base % mod;",
      "    int res = 1;",
      "    while (val > 0)",
      "    {",
      "        if ((val & 1))",
      "        {",
      "            res = mult(res, base);",
      "        }",
      "        base = mult(base, base);",
      "        val = (val >> 1);",
      "    }",
      "    return res;",
      "}",
      "",
      "int modInverse(int num)",
      "{",
      "    return power(num, mod - 2);",
      "}",
      "",
      "int divide(int val1, int val2)",
      "{",
      "    int val3 = modInverse(val2);",
      "    int ans = mult(val1, val3);",
      "    return ans;",
      "}",
      "",
      "vector<int> factorial(max_n + 1);",
      "vector<int> mmi(max_n + 1);",
      "void calculate_factorial()",
      "{",
      "    factorial[0] = 1;",
      "    mmi[0] = 1;",
      "    for (int i = 1; i <= max_n; i++)",
      "    {",
      "        factorial[i] = mult(factorial[i - 1], i);",
      "    }",
      "    mmi[max_n] = modInverse(factorial[max_n]);",
      "    for (int i = max_n - 1; i >= 1; i--)",
      "    {",
      "        mmi[i] = mult(mmi[i + 1], i + 1);",
      "    }",
      "}",
      "",
      "int nCr(int n, int r)",
      "{",
      "    if (n < r)",
      "        return 0;",
      "    if (r == 0)",
      "        return 1;",
      "",
      "    return mult(mult(factorial[n], mmi[r]), mmi[n - r]);",
      "}",
      "",
      "void solve(){",
      "    $0}",
      "",
      "int32_t main()",
      "{",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    calculate_factorial();",
      "    // freopen(\"input.in\", \"r\", stdin);",
      "    // freopen(\"output.out\", \"w\", stdout);",
      "    int no_of_testcases = 1;",
      "    // $1cin >> no_of_testcases;",
      "    for (int i = 1; i <= no_of_testcases; i++)",
      "    {",
      "        // cout << \"Case #\" << i << \": \";",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ]
  },
  "sort vector": {
    "prefix": "sort",
    "description": "sort vector",
    "body": ["sort(all(${1:array}));"]
  },
  "sort vector reverse": {
    "prefix": "sort reverse",
    "description": "sort vector reverse",
    "body": ["sort(all(${1:array}), greater<${2:int}>());"]
  },
  "random generator": {
    "prefix": "random",
    "description": "function which returns a random number in a range.",
    "body": [
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "",
      "int rnd(int l, int r)",
      "{",
      "    return uniform_int_distribution<int>(l, r)(rng);",
      "}"
    ]
  },
  "Disjoint Sets Union Class": {
    "prefix": "DSU",
    "description": "Disjoint Sets Union Class",
    "body": [
      "// Tree compression + size(rank) optimised DSU",
      "class disjoint_sets",
      "{",
      "private:",
      "    int N;",
      "    vector<int> ancestor;",
      "    vector<int> children;",
      "",
      "public:",
      "    // Empty Constructor",
      "    disjoint_sets()",
      "    {",
      "        ",
      "    }",
      "",
      "    // Constructor",
      "    disjoint_sets(int size)",
      "    {",
      "        N = size;",
      "        ancestor.resize(N);",
      "        children.resize(N, 1);",
      "        iota(all(ancestor), 0);",
      "    }",
      "",
      "    int find_root(int X)",
      "    {",
      "        if (ancestor[X] == X)",
      "        {",
      "            return X;",
      "        }",
      "        ancestor[X] = find_root(ancestor[X]);",
      "        return ancestor[X];",
      "    }",
      "",
      "    void merge_sets(int X, int Y)",
      "    {",
      "        int root_X = find_root(X);",
      "        int root_Y = find_root(Y);",
      "        if (root_X == root_Y)",
      "        {",
      "            return;",
      "        }",
      "        if (children[root_X] > children[root_Y])",
      "        {",
      "            swap(root_X, root_Y);",
      "        }",
      "        ancestor[root_X] = root_Y;",
      "        children[root_Y] += children[root_X];",
      "        children[root_X] = 0;",
      "    }",
      "};"
    ]
  },
  "sieve template": {
    "prefix": "sieve",
    "description": "sieve template",
    "body": [
      "const int MAX_LIMIT = ${1:1e7};",
      "vector<int> primes;",
      "vector<int> spf;",
      "vector<bool> isPrime;",
      "",
      "void sieve()",
      "{",
      "    primes.reserve(MAX_LIMIT / 10);",
      "    isPrime.resize(MAX_LIMIT + 1, true);",
      "    spf.resize(MAX_LIMIT + 1);",
      "",
      "    isPrime[1] = false;",
      "    iota(all(spf), 0);",
      "",
      "    for (int i = 2; i <= MAX_LIMIT; i++)",
      "    {",
      "        if (isPrime[i])",
      "        {",
      "            primes.push_back(i);",
      "            for (int j = i * i; j <= MAX_LIMIT; j += i)",
      "            {",
      "                if (isPrime[j])",
      "                {",
      "                    isPrime[j] = false;",
      "                    spf[j] = i;",
      "                }",
      "            }",
      "        }",
      "    }",
      "}",
      "",
      "void get_factors(int num, vector<int>& factors)",
      "{",
      "    factors.reserve(log2(num) + 1);",
      "    while (num != 1)",
      "    {",
      "        factors.push_back(spf[num]);",
      "        num /= spf[num];",
      "    }",
      "}"
    ]
  },
  "Matrix Exponentiation": {
    "prefix": "matrix exponentiation",
    "body": [
      "vector<vector<int>> multiply(vector<vector<int>> A, vector<vector<int>> B)",
      "{",
      "    int N = A.size();",
      "    vector<vector<int>> ans(N, vector<int>(N, 0));",
      "    for (int i = 0; i < N; i++)",
      "    {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "            for (int k = 0; k < N; k++)",
      "            {",
      "                ans[i][j] += ((A[i][k] % mod) * (B[k][j] % mod)) % mod;",
      "                ans[i][j] = ans[i][j] % mod;",
      "            }",
      "        }",
      "    }",
      "    return ans;",
      "}",
      "",
      "vector<vector<int>> power(vector<vector<int>> A, int y)",
      "{",
      "    int N = A.size();",
      "    vector<vector<int>> res(N, vector<int>(N, 0));",
      "    int k = 0;",
      "    for (int i = 0; i < N; i++)",
      "    {",
      "        res[i][k] = 1;",
      "        k++;",
      "    }",
      "",
      "    while (y > 0)",
      "    {",
      "        if (y & 1)",
      "        {",
      "            res = multiply(res, A);",
      "        }",
      "        A = multiply(A, A);",
      "        y = y >> 1;",
      "    }",
      "    return res;",
      "}"
    ],
    "description": "Matrix Exponentiation"
  },
  "Segment Tree Struct": {
    "prefix": "Range",
    "description": "Segment Tree Struct",
    "body": [
      "struct segment_tree",
      "{",
      "    int N;",
      "    ${1:int} def_val;",
      "    vector<${1:int}> tree;",
      "",
      "    inline ${1:int} merge_nodes(${1:int} left, ${1:int} right)",
      "    {",
      "        ${0}",
      "    }",
      "",
      "    segment_tree()",
      "    {",
      "        // Empty Constructor",
      "    }",
      "",
      "    segment_tree(int len, ${1:int} val)",
      "    {",
      "        N = (1LL << (int)(ceill(log2(len))));",
      "        def_val = val;",
      "        ",
      "        tree.resize(N << 1, def_val);",
      "    }",
      "",
      "    segment_tree(vector<${1:int}> &elements, ${1:int} val)",
      "    {",
      "        N = (1 << (int)(ceill(log2((int)elements.size()))));",
      "        def_val = val;",
      "",
      "        tree.resize(N << 1, def_val);",
      "        for (int i = 0; i < (int)elements.size(); i++)",
      "        {",
      "            tree[N + i] = elements[i];",
      "        }",
      "",
      "        build_inner(1);",
      "    }",
      "",
      "    ${1:int} query(int l, int r)",
      "    {",
      "        return query_inner(1, l, r, 0, N - 1);",
      "    }",
      "",
      "    void update(int pos, ${1:int} val)",
      "    {",
      "        tree[N + pos] = val;",
      "        update_inner((N + pos) >> 1);",
      "    }",
      "",
      "    ${1:int} build_inner(int current_node)",
      "    {",
      "        if (current_node >= N)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "        tree[current_node] = merge_nodes(build_inner((current_node << 1)), build_inner((current_node << 1) + 1));",
      "        return tree[current_node];",
      "    }",
      "",
      "    void update_inner(int current_node)",
      "    {",
      "        if (current_node == 0)",
      "        {",
      "            return;",
      "        }",
      "",
      "        tree[current_node] = merge_nodes(tree[(current_node << 1)], tree[(current_node << 1) + 1]);",
      "        update_inner((current_node >> 1));",
      "    }",
      "",
      "    ${1:int} query_inner(int current_node, int query_l, int query_r, int tree_l, int tree_r)",
      "    {",
      "        if (query_l <= tree_l && tree_r <= query_r)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "",
      "        if (query_l > tree_r || query_r < tree_l)",
      "        {",
      "            return def_val;",
      "        }",
      "",
      "        int mid = ((tree_l + tree_r) >> 1);",
      "        return merge_nodes(query_inner((current_node << 1), query_l, query_r, tree_l, mid), query_inner((current_node << 1) + 1, query_l, query_r, mid + 1, tree_r));",
      "    }",
      "};"
    ]
  },
  "Sparse Table": {
    "prefix": "Static Range",
    "description": "Sparse Table",
    "body": [
      "struct sparse_table",
      "{",
      "    int N;",
      "    int max_power;",
      "    ${1:int} def_val;",
      "    vector<int> log_value;",
      "    vector<vector<${1:int}>> table;",
      "",
      "    ${1:int} merge_nodes(${1:int} left, ${1:int} right)",
      "    {",
      "        ${0}",
      "    }",
      "",
      "    sparse_table()",
      "    {",
      "        ",
      "    }",
      "",
      "    void precompute_logs()",
      "    {",
      "        log_value[0] = -1e9;",
      "        log_value[1] = 0;",
      "        for (int i = 2; i <= N; i++)",
      "        {",
      "            log_value[i] = log_value[i / 2] + 1;",
      "        }",
      "    }",
      "",
      "    sparse_table(vector<${1:int}> &elements, ${1:int} val)",
      "    {",
      "        N = elements.size();",
      "        max_power = (int)floor(log2((int)elements.size()));",
      "        def_val = val;",
      "        log_value.resize(N + 1, 0);",
      "        table.resize(N, vector<${1:int}>(max_power + 1, val));",
      "        precompute_logs();",
      "        build(elements);",
      "    }",
      "",
      "    void build(vector<${1:int}> &elements)",
      "    {",
      "        for (int i = 0; i < N; i++)",
      "        {",
      "            table[i][0] = elements[i];",
      "        }",
      "",
      "        for (int j = 1; j <= max_power; j++)",
      "        {",
      "            for (int i = 0; i < N; i++)",
      "            {",
      "                if (i + (1 << j) - 1 >= N)",
      "                {",
      "                    break;",
      "                }",
      "                table[i][j] = merge_nodes(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);",
      "            }",
      "        }",
      "    }",
      "",
      "    ${1:int} query(int l, int r)",
      "    {",
      "        int len = r - l + 1;",
      "        int bit = log_value[len];",
      "        return merge_nodes(table[l][bit], table[r - (1 << bit) + 1][bit]);",
      "    }",
      "};"
    ]
  },
  "Lowest Common ancestor": {
    "prefix": "lowest common ancestor ",
    "description": "Lowest Common ancestor",
    "body": [
      "struct LCA",
      "{",
      "    int num_of_nodes, len;",
      "    pair<int, int> def_val;",
      "    vector<int> first;",
      "    vector<int> euler;",
      "    vector<int> depth;",
      "    vector<pair<int, int>> tree;",
      "",
      "    LCA()",
      "    {",
      "        // Empty Constructor",
      "    }",
      "",
      "    LCA(vector<vector<int>> &adj, int root = 1)",
      "    {",
      "        num_of_nodes = (int)adj.size() - 1;",
      "        first.resize(num_of_nodes + 1);",
      "        euler.resize(2 * num_of_nodes);",
      "        depth.resize(num_of_nodes + 1, 1e9);",
      "",
      "        int counter = 1;",
      "        dfs(root, 0, adj, counter, 0);",
      "",
      "        len = (1 << (int)(ceill(log2((int)euler.size()))));",
      "        def_val = {1e9, 1e9};",
      "        tree.resize(len << 1, def_val);",
      "        for (int i = 0; i < (int)euler.size(); i++)",
      "        {",
      "            tree[len + i] = {depth[euler[i]], euler[i]};",
      "        }",
      "        build(1);",
      "    }",
      "",
      "    int get_lca(int node1, int node2)",
      "    {",
      "        int left = first[node1], right = first[node2];",
      "",
      "        if (left > right)",
      "        {",
      "            swap(left, right);",
      "        }",
      "",
      "        return query(1, left, right, 0, len - 1).second;",
      "    }",
      "",
      "    int get_dist(int node1, int node2)",
      "    {",
      "        int common = get_lca(node1, node2);",
      "        int dist = depth[node1] + depth[node2] - 2 * depth[common];",
      "        return dist;",
      "    }",
      "",
      "private:",
      "    void dfs(int node, int parent, vector<vector<int>> &adj, int &counter, int current_depth = 0)",
      "    {",
      "        depth[node] = current_depth;",
      "        first[node] = counter;",
      "        euler[counter] = node;",
      "        counter++;",
      "        for (auto next_node : adj[node])",
      "        {",
      "            if (next_node != parent)",
      "            {",
      "                dfs(next_node, node, adj, counter, current_depth + 1);",
      "                euler[counter] = node;",
      "                counter++;",
      "            }",
      "        }",
      "    }",
      "",
      "    pair<int, int> merge_nodes(pair<int, int> left, pair<int, int> right)",
      "    {",
      "        return (left.first < right.first) ? left : right;",
      "    }",
      "",
      "    pair<int, int> build(int current_node)",
      "    {",
      "        if (current_node >= len)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "        tree[current_node] = merge_nodes(build((current_node << 1)), build((current_node << 1) + 1));",
      "        return tree[current_node];",
      "    }",
      "",
      "    pair<int, int> query(int current_node, int query_l, int query_r, int tree_l, int tree_r)",
      "    {",
      "        if (query_l <= tree_l && tree_r <= query_r)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "",
      "        if (query_l > tree_r || query_r < tree_l)",
      "        {",
      "            return def_val;",
      "        }",
      "",
      "        int mid = ((tree_l + tree_r) >> 1);",
      "        return merge_nodes(query((current_node << 1), query_l, query_r, tree_l, mid), query((current_node << 1) + 1, query_l, query_r, mid + 1, tree_r));",
      "    }",
      "};"
    ]
  },
  "Lazy Segment Tree": {
    "prefix": "Lazy Range",
    "description": "Lazy Segment Tree",
    "body": [
      "struct lazy_tree",
      "{",
      "    int n, def_val;",
      "    pair<int, int> def_lazy;",
      "    vector<int> tree;",
      "    vector<pair<bool, int>> lazy;",
      "",
      "    // Empty Constructor",
      "    lazy_tree()",
      "    {",
      "    }",
      "",
      "    // Initialize by array",
      "    lazy_tree(vector<int> &leafs, int val, pair<int, int> lazy_val = {1, 0})",
      "    {",
      "        def_lazy = lazy_val;",
      "        def_val = val;",
      "        n = (1LL << (int)ceill(log2((int)leafs.size())));",
      "",
      "        tree.resize(2 * n, def_val);",
      "        lazy.resize(2 * n, def_lazy);",
      "        for (int i = 0; i < (int)leafs.size(); i++)",
      "        {",
      "            tree[n + i] = leafs[i];",
      "        }",
      "",
      "        build_inner(1);",
      "    }",
      "",
      "    // Initialize by size",
      "    lazy_tree(int len, int val, pair<int, int> lazy_val = {1, 0})",
      "    {",
      "        def_lazy = lazy_val;",
      "        def_val = val;",
      "        n = (1LL << (int)ceill(log2(len)));",
      "",
      "        tree.resize(2 * n, def_val);",
      "        lazy.resize(2 * n, def_lazy);",
      "",
      "        build_inner(1);",
      "    }",
      "",
      "    inline int merge_nodes(int left, int right)",
      "    {",
      "        return left + right;",
      "    }",
      "",
      "    inline int get_value(int node, int children)",
      "    {",
      "        return (tree[node] * lazy[node].first + children * lazy[node].second);",
      "    }",
      "",
      "    inline int query(int l, int r)",
      "    {",
      "        return query_inner(1, 0, n - 1, l, r);",
      "    }",
      "",
      "    inline int add(int l, int r, int val)",
      "    {",
      "        return update_inner(1, 0, n - 1, l, r, 1, val);",
      "    }",
      "",
      "    inline int assign(int l, int r, int val)",
      "    {",
      "        return update_inner(1, 0, n - 1, l, r, 0, val);",
      "    }",
      "",
      "private:",
      "    inline void update_lazy_value(int node, bool type, int val)",
      "    {",
      "        if (node >= n)",
      "        {",
      "            tree[node] = tree[node] * type + val;",
      "            return;",
      "        }",
      "",
      "        if (type)",
      "        {",
      "            lazy[node].second += val;",
      "        }",
      "        else",
      "        {",
      "            lazy[node].first = type;",
      "            lazy[node].second = val;",
      "        }",
      "    }",
      "",
      "    inline void push_lazy_value(int node, int children)",
      "    {",
      "        update_lazy_value((node << 1), lazy[node].first, lazy[node].second);",
      "        update_lazy_value((node << 1) + 1, lazy[node].first, lazy[node].second);",
      "        tree[node] = get_value(node, children);",
      "        lazy[node] = def_lazy;",
      "    }",
      "",
      "    int build_inner(int node)",
      "    {",
      "        if (node >= n)",
      "        {",
      "            return tree[node];",
      "        }",
      "        tree[node] = merge_nodes(build_inner((node << 1)), build_inner((node << 1) + 1));",
      "        return tree[node];",
      "    }",
      "",
      "    int query_inner(int node, int node_l, int node_r, int query_l, int query_r)",
      "    {",
      "        if (query_l <= node_l && node_r <= query_r)",
      "        {",
      "            return get_value(node, (node_r - node_l + 1));",
      "        }",
      "        else if (query_l > node_r || query_r < node_l)",
      "        {",
      "            return def_val;",
      "        }",
      "        else",
      "        {",
      "            push_lazy_value(node, node_r - node_l + 1);",
      "            int mid = (node_l + node_r) >> 1;",
      "            return merge_nodes(query_inner((node << 1), node_l, mid, query_l, query_r), query_inner((node << 1) + 1, mid + 1, node_r, query_l, query_r));",
      "        }",
      "    }",
      "",
      "    int update_inner(int node, int node_l, int node_r, int query_l, int query_r, int type, int value)",
      "    {",
      "        if (query_l <= node_l && node_r <= query_r)",
      "        {",
      "            update_lazy_value(node, type, value);",
      "            return get_value(node, node_r - node_l + 1);",
      "        }",
      "        else if (query_l > node_r || query_r < node_l)",
      "        {",
      "            return get_value(node, node_r - node_l + 1);",
      "        }",
      "        else",
      "        {",
      "            push_lazy_value(node, node_r - node_l + 1);",
      "            int mid = (node_l + node_r) >> 1;",
      "            tree[node] = merge_nodes(update_inner((node << 1), node_l, mid, query_l, query_r, type, value), update_inner((node << 1) + 1, mid + 1, node_r, query_l, query_r, type, value));",
      "            return tree[node];",
      "        }",
      "    }",
      "};"
    ]
  },
  "Heavy Light Decomposition": {
    "prefix": "Decomposition Heavy Light ",
    "description": "Heavy Light Decomposition",
    "body": [
      "struct LCA",
      "{",
      "    int num_of_nodes, len;",
      "    pair<int, int> def_val;",
      "    vector<int> first;",
      "    vector<int> euler;",
      "    vector<int> depth;",
      "    vector<pair<int, int>> tree;",
      "",
      "    LCA()",
      "    {",
      "        // Empty Constructor",
      "    }",
      "",
      "    LCA(vector<vector<int>> &adj, int root = 1)",
      "    {",
      "        num_of_nodes = (int)adj.size() - 1;",
      "        first.resize(num_of_nodes + 1);",
      "        euler.resize(2 * num_of_nodes);",
      "        depth.resize(num_of_nodes + 1, 1e18);",
      "",
      "        int counter = 1;",
      "        dfs(root, 0, adj, counter, 0);",
      "",
      "        len = (1 << (int)(ceill(log2((int)euler.size()))));",
      "        def_val = {1e18, 1e18};",
      "        tree.resize(len << 1, def_val);",
      "        for (int i = 0; i < (int)euler.size(); i++)",
      "        {",
      "            tree[len + i] = {depth[euler[i]], euler[i]};",
      "        }",
      "        build(1);",
      "    }",
      "",
      "    int lca(int node1, int node2)",
      "    {",
      "        int left = first[node1], right = first[node2];",
      "",
      "        if (left > right)",
      "        {",
      "            swap(left, right);",
      "        }",
      "",
      "        return query(1, left, right, 0, len - 1).second;",
      "    }",
      "",
      "private:",
      "    void dfs(int node, int parent, vector<vector<int>> &adj, int &counter, int current_depth = 0)",
      "    {",
      "        depth[node] = current_depth;",
      "        first[node] = counter;",
      "        euler[counter] = node;",
      "        counter++;",
      "        for (auto next_node : adj[node])",
      "        {",
      "            if (next_node != parent)",
      "            {",
      "                dfs(next_node, node, adj, counter, current_depth + 1);",
      "                euler[counter] = node;",
      "                counter++;",
      "            }",
      "        }",
      "    }",
      "",
      "    pair<int, int> merge_nodes(pair<int, int> left, pair<int, int> right)",
      "    {",
      "        return (left.first < right.first) ? left : right;",
      "    }",
      "",
      "    pair<int, int> build(int current_node)",
      "    {",
      "        if (current_node >= len)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "        tree[current_node] = merge_nodes(build((current_node << 1)), build((current_node << 1) + 1));",
      "        return tree[current_node];",
      "    }",
      "",
      "    pair<int, int> query(int current_node, int query_l, int query_r, int tree_l, int tree_r)",
      "    {",
      "        if (query_l <= tree_l && tree_r <= query_r)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "",
      "        if (query_l > tree_r || query_r < tree_l)",
      "        {",
      "            return def_val;",
      "        }",
      "",
      "        int mid = ((tree_l + tree_r) >> 1);",
      "        return merge_nodes(query((current_node << 1), query_l, query_r, tree_l, mid), query((current_node << 1) + 1, query_l, query_r, mid + 1, tree_r));",
      "    }",
      "};",
      "",
      "struct segment_tree",
      "{",
      "    int N;",
      "    int def_val;",
      "    vector<int> tree;",
      "",
      "    int merge_nodes(int left, int right)",
      "    {",
      "        return max(left, right);",
      "    }",
      "",
      "    segment_tree()",
      "    {",
      "        // Empty Constructor",
      "    }",
      "",
      "    segment_tree(vector<int> &elements, int val)",
      "    {",
      "        N = (1 << (int)(ceill(log2((int)elements.size()))));",
      "        def_val = val;",
      "",
      "        tree.resize(N << 1, def_val);",
      "        for (int i = 0; i < (int)elements.size(); i++)",
      "        {",
      "            tree[N + i] = elements[i];",
      "        }",
      "",
      "        build_inner(1);",
      "    }",
      "",
      "    int query(int l, int r)",
      "    {",
      "        return query_inner(1, l, r, 0, N - 1);",
      "    }",
      "",
      "    void update(int pos, int val)",
      "    {",
      "        tree[N + pos] = val;",
      "        update_inner((N + pos) >> 1);",
      "    }",
      "",
      "private:",
      "    int build_inner(int current_node)",
      "    {",
      "        if (current_node >= N)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "        tree[current_node] = merge_nodes(build_inner((current_node << 1)), build_inner((current_node << 1) + 1));",
      "        return tree[current_node];",
      "    }",
      "",
      "    void update_inner(int current_node)",
      "    {",
      "        if (current_node == 0)",
      "        {",
      "            return;",
      "        }",
      "",
      "        tree[current_node] = merge_nodes(tree[(current_node << 1)], tree[(current_node << 1) + 1]);",
      "        update_inner((current_node >> 1));",
      "    }",
      "",
      "    int query_inner(int current_node, int query_l, int query_r, int tree_l, int tree_r)",
      "    {",
      "        if (query_l <= tree_l && tree_r <= query_r)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "",
      "        if (query_l > tree_r || query_r < tree_l)",
      "        {",
      "            return def_val;",
      "        }",
      "",
      "        int mid = ((tree_l + tree_r) >> 1);",
      "        return merge_nodes(query_inner((current_node << 1), query_l, query_r, tree_l, mid), query_inner((current_node << 1) + 1, query_l, query_r, mid + 1, tree_r));",
      "    }",
      "};",
      "",
      "struct HLD",
      "{",
      "    int N;",
      "    int seg = 1, visited = 0;",
      "    vector<int> segment, start, pos, children, uplink;",
      "    segment_tree tree;",
      "",
      "    // Input",
      "    vector<int> value;",
      "    vector<vector<int>> adj;",
      "",
      "    // Extra",
      "    LCA ds;",
      "",
      "    HLD()",
      "    {",
      "        // Empty Constructor",
      "    }",
      "",
      "    HLD(int nodes, vector<vector<int>> &temp_adj, vector<int> &temp_value)",
      "    {",
      "        reset();",
      "",
      "        N = nodes;",
      "        segment.resize(N + 1);",
      "        start.resize(N + 1);",
      "        pos.resize(N + 1);",
      "        uplink.resize(N + 1);",
      "        children.resize(N + 1);",
      "        value = temp_value;",
      "        adj = temp_adj;",
      "",
      "        dfs(1, 0);",
      "",
      "        start[seg] = visited;",
      "",
      "        decompose(1, 0, 0);",
      "",
      "        vector<int> leafs(N + 1);",
      "        for (int i = 1; i <= N; i++)",
      "        {",
      "            leafs[start[segment[i]] + pos[i]] = value[i];",
      "        }",
      "",
      "        tree = segment_tree(leafs, 0);",
      "",
      "        // Extra",
      "        ds = LCA(adj);",
      "    }",
      "",
      "    void reset()",
      "    {",
      "        segment.clear();",
      "        start.clear();",
      "        pos.clear();",
      "        uplink.clear();",
      "        children.clear();",
      "        value.clear();",
      "        adj.clear();",
      "        tree = segment_tree();",
      "",
      "        // Extra",
      "        ds = LCA();",
      "    }",
      "",
      "    int dfs(int node, int parent)",
      "    {",
      "        children[node] = 1;",
      "        for (auto &&child : adj[node])",
      "        {",
      "            if (child != parent)",
      "            {",
      "                children[node] += dfs(child, node);",
      "            }",
      "        }",
      "        return children[node];",
      "    }",
      "",
      "    void decompose(int node, int parent, int cur)",
      "    {",
      "        visited++;",
      "        segment[node] = seg;",
      "        pos[node] = cur;",
      "",
      "        int heavy = 0;",
      "        int max_size = 0;",
      "        for (auto &&child : adj[node])",
      "        {",
      "            if (child != parent)",
      "            {",
      "                if (max_size < children[child])",
      "                {",
      "                    heavy = child;",
      "                    max_size = children[child];",
      "                }",
      "            }",
      "        }",
      "",
      "        if (heavy != 0)",
      "        {",
      "            decompose(heavy, node, cur + 1);",
      "        }",
      "",
      "        for (auto &&child : adj[node])",
      "        {",
      "            if (child != parent && child != heavy)",
      "            {",
      "                seg++;",
      "                uplink[seg] = node;",
      "                start[seg] = visited;",
      "                decompose(child, node, 0);",
      "            }",
      "        }",
      "    }",
      "",
      "    void update(int node, int val)",
      "    {",
      "        tree.update(start[segment[node]] + pos[node], val);",
      "    }",
      "",
      "    // Extra",
      "    int solve_query(int node, int common)",
      "    {",
      "        int ans = 0;",
      "        while (segment[node] != segment[common])",
      "        {",
      "            ans = max(ans, tree.query(start[segment[node]], start[segment[node]] + pos[node]));",
      "            node = uplink[segment[node]];",
      "        }",
      "        ans = max(ans, tree.query(start[segment[common]] + pos[common], start[segment[node]] + pos[node]));",
      "        return ans;",
      "    }",
      "",
      "    int query(int node1, int node2)",
      "    {",
      "        int common = ds.lca(node1, node2);",
      "        return max(solve_query(node1, common), solve_query(node2, common));",
      "    }",
      "};"
    ]
  },
  "Input Vector": {
    "prefix": "Input Vector",
    "description": "Input Vector",
    "body": [
      "vector<int> ${1:arr}(${2:length});",
      "for (int ${3:iter} = 0; ${3:iter} < ${2:length}; ${3:iter}++)",
      "{",
      "    cin >> ${1:arr}[${3:iter}];",
      "}"
    ]
  },
  "for": {
    "prefix": "for",
    "description": "for loop",
    "body": [
      "for (int ${1:iter} = 0; ${1:iter} < (int)${2:length}; ${1:iter}++)",
      "{",
      "    $0",
      "}"
    ]
  },
  "forr": {
    "prefix": "rfor",
    "description": "reverse for loop",
    "body": [
      "for (int ${1:iter} = (int)${2:length} - 1; ${1:iter} >= 0; ${1:iter}--)",
      "{",
      "    $0",
      "}"
    ]
  },
  "DSU on Trees": {
    "prefix": "DSU on Trees",
    "description": "",
    "body": [
      "const int max_n = 5e5 + 10;",
      "vector<vector<int>> adj;",
      "int vals[max_n];",
      "int sz[max_n];",
      "int heavy = -1;",
      "",
      "int sack_size(int node, int parent = 0)",
      "{",
      "    sz[node] = 1;",
      "    int max_sz = 0;",
      "    for (int i = 0; i < (int)adj[node].size(); i++)",
      "    {",
      "        if (adj[node][i] == parent)",
      "        {",
      "            continue;",
      "        }",
      "        int temp = sack_size(adj[node][i], node);",
      "        sz[node] += temp;",
      "        if (temp > max_sz)",
      "        {",
      "            max_sz = temp;",
      "            swap(adj[node][0], adj[node][i]);",
      "        }",
      "    }",
      "    return sz[node];",
      "}",
      "",
      "void sack_add(int node, int parent)",
      "{",
      "    // Do Something Here to change the value",
      "    for (int i = 0; i < (int)adj[node].size(); i++)",
      "    {",
      "        if (adj[node][i] != parent && adj[node][i] != heavy)",
      "        {",
      "            sack_add(adj[node][i], node);",
      "        }",
      "    }",
      "}",
      "",
      "void sack_dfs(int node, int parent, int keep)",
      "{",
      "    for (int i = 1; i < (int)adj[node].size(); i++)",
      "    {",
      "        if (adj[node][i] != parent)",
      "        {",
      "            sack_dfs(adj[node][i], node, 0);",
      "        }",
      "    }",
      "",
      "    if (sz[node] != 1)",
      "    {",
      "        sack_dfs(adj[node][0], node, 1);",
      "        heavy = adj[node][0];",
      "    }",
      "",
      "    sack_add(node, parent);",
      "",
      "    // Handle root seperately if you are going ",
      "    // to dfs only on the light childs",
      "    // Answer Queries Here",
      "",
      "    heavy = -1;",
      "    if (!keep)",
      "    {",
      "        sack_add(node, parent);",
      "    }",
      "}"
    ]
  },
  "Heavy Decomposition": {
    "prefix": "Decomposition Heavy ",
    "description": "",
    "body": [
      "struct segment_tree",
      "{",
      "    int N;",
      "    int def_val;",
      "    vector<int> tree;",
      " ",
      "    int merge_nodes(int left, int right)",
      "    {",
      "        return max(left, right);",
      "    }",
      " ",
      "    segment_tree()",
      "    {",
      "        // Empty Constructor",
      "    }",
      " ",
      "    segment_tree(int len, int val)",
      "    {",
      "        N = (1LL << (int)(ceill(log2(len))));",
      "        def_val = val;",
      "        ",
      "        tree.resize(N << 1, def_val);",
      "    }",
      " ",
      "    segment_tree(vector<int> &elements, int val)",
      "    {",
      "        N = (1 << (int)(ceill(log2((int)elements.size()))));",
      "        def_val = val;",
      " ",
      "        tree.resize(N << 1, def_val);",
      "        for (int i = 0; i < (int)elements.size(); i++)",
      "        {",
      "            tree[N + i] = elements[i];",
      "        }",
      " ",
      "        build_inner(1);",
      "    }",
      " ",
      "    int query(int l, int r)",
      "    {",
      "        return query_inner(1, l, r, 0, N - 1);",
      "    }",
      " ",
      "    void update(int pos, int val)",
      "    {",
      "        tree[N + pos] = val;",
      "        update_inner((N + pos) >> 1);",
      "    }",
      " ",
      "private:",
      "    int build_inner(int current_node)",
      "    {",
      "        if (current_node >= N)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "        tree[current_node] = merge_nodes(build_inner((current_node << 1)), build_inner((current_node << 1) + 1));",
      "        return tree[current_node];",
      "    }",
      " ",
      "    void update_inner(int current_node)",
      "    {",
      "        if (current_node == 0)",
      "        {",
      "            return;",
      "        }",
      " ",
      "        tree[current_node] = merge_nodes(tree[(current_node << 1)], tree[(current_node << 1) + 1]);",
      "        update_inner((current_node >> 1));",
      "    }",
      " ",
      "    int query_inner(int current_node, int query_l, int query_r, int tree_l, int tree_r)",
      "    {",
      "        if (query_l <= tree_l && tree_r <= query_r)",
      "        {",
      "            return tree[current_node];",
      "        }",
      " ",
      "        if (query_l > tree_r || query_r < tree_l)",
      "        {",
      "            return def_val;",
      "        }",
      " ",
      "        int mid = ((tree_l + tree_r) >> 1);",
      "        return merge_nodes(query_inner((current_node << 1), query_l, query_r, tree_l, mid), query_inner((current_node << 1) + 1, query_l, query_r, mid + 1, tree_r));",
      "    }",
      "};",
      " ",
      "struct HLD",
      "{",
      "    vector<int> euler, uplink, path_of, path_start, sz;",
      "    vector<vector<int>> subtree;",
      " ",
      "    // Segment Tree",
      "    int tree_len;",
      "    segment_tree tree;",
      " ",
      " ",
      "    // one time use variables",
      "    int cur_path = 1, visited = 1;",
      " ",
      "    // INPUT",
      "    int N, def_val;",
      "    vector<vector<int>> adj;",
      " ",
      "    HLD()",
      "    {",
      "    }",
      " ",
      "    HLD(int n, vector<vector<int>> &g, vector<int> &value)",
      "    {",
      "        N = n;",
      "        adj = g;",
      " ",
      "        euler.resize(N + 1);",
      "        uplink.resize(N + 1);",
      "        path_of.resize(N + 1);",
      "        sz.resize(N + 1);",
      "        path_start.resize(N + 1);",
      "        subtree.resize(N + 1, vector<int>(2));",
      " ",
      "        hld_size(1, 0);",
      " ",
      "        path_start[cur_path] = 1;",
      " ",
      "        hld_decompose(1, 0);",
      " ",
      "        vector<int> leafs(N + 1);",
      "        for (int i = 1; i <= N; i++)",
      "        {",
      "            leafs[euler[i]] = value[i];",
      "        }",
      "        tree = segment_tree(leafs, 0);",
      "    }",
      " ",
      "    int hld_size(int node, int parent)",
      "    {",
      "        sz[node] = 1;",
      "        int max_sz = 0;",
      "        for (int i = 0; i < (int)adj[node].size(); i++)",
      "        {",
      "            if (adj[node][i] != parent)",
      "            {",
      "                int temp = hld_size(adj[node][i], node);",
      "                sz[node] += temp;",
      "                if (temp > max_sz)",
      "                {",
      "                    max_sz = temp;",
      "                    swap(adj[node][0], adj[node][i]);",
      "                }",
      "            }",
      "        }",
      "        return sz[node];",
      "    }",
      " ",
      "    void hld_decompose(int node, int parent)",
      "    {",
      "        euler[node] = visited;",
      "        path_of[euler[node]] = cur_path;",
      "        subtree[euler[node]][0] = visited;",
      "        visited++;",
      " ",
      "        if (sz[node] != 1)",
      "        {",
      "            hld_decompose(adj[node][0], node);",
      "        }",
      " ",
      "        for (int i = 1; i < (int)adj[node].size(); i++)",
      "        {",
      "            if (adj[node][i] != parent)",
      "            {",
      "                cur_path++;",
      "                uplink[cur_path] = euler[node];",
      "                path_start[cur_path] = visited;",
      "                hld_decompose(adj[node][i], node);",
      "            }",
      "        }",
      " ",
      "        subtree[euler[node]][1] = visited - 1;",
      "    }",
      " ",
      "    void update(int node, int val)",
      "    {",
      "        tree.update(euler[node], val);",
      "    }",
      " ",
      "    int traverse(int node, int root)",
      "    {",
      "        int ans = 0;",
      "        while (path_of[node] != path_of[root])",
      "        {",
      "            ans = max(ans, tree.query(path_start[path_of[node]], node));",
      "            node = uplink[path_of[node]];",
      "        }",
      "        ans = max(ans, tree.query(root, node));",
      "        return ans;",
      "    }",
      "",
      "    int query_subtree(int node)",
      "    {",
      "        return tree.query(subtree[euler[node]][0], subtree[euler[node]][1]);",
      "    }",
      "};"
    ]
  },
  "Linear Sieve": {
    "prefix": "Linear Sieve",
    "description": "O(N) sieve",
    "body": [
      "const int MAX_PRIMES = 1e5;",
      "",
      "vector<int> primes;",
      "vector<bool> isPrime(MAX_PRIMES + 1, true);",
      "",
      "primes.reserve((MAX_PRIMES + 10) / 10);",
      "isPrime[1] = false;",
      "",
      "for (int i = 2; i <= MAX_PRIMES; i++)",
      "{",
      "    if (isPrime[i])",
      "    {",
      "        primes.push_back(i);",
      "    }",
      "",
      "    for (int j = 0; j < (int)primes.size(); j++)",
      "    {",
      "        if (i * primes[j] > MAX_PRIMES)",
      "        {",
      "            break;",
      "        }",
      "",
      "        isPrime[i * primes[j]] = false;",
      "",
      "        if (i % primes[j] == 0)",
      "        {",
      "            break;",
      "        }",
      "    }",
      "}"
    ]
  },
  "1-based Input Vector": {
    "prefix": "Input Vector 1-based ",
    "description": "1-based Input Vector",
    "body": [
      "vector<int> ${1:arr}(${2:length} + 1);",
      "for (int ${3:iter} = 1; ${3:iter} <= ${2:length}; ${3:iter}++)",
      "{",
      "    cin >> ${1:arr}[${3:iter}];",
      "}"
    ]
  },
  "1-based for": {
    "prefix": "for 1-based ",
    "description": "1-based for",
    "body": [
      "for (int ${1:iter} = 1; ${1:iter} <= (int)${2:length}; ${1:iter}++)",
      "{",
      "    $0",
      "}"
    ]
  },
  "1-based revfor": {
    "prefix": "rfor 1-based ",
    "description": "1-based reverse for loop",
    "body": [
      "for (int ${1:iter} = (int)${2:length}; ${1:iter} >= 1; ${1:iter}--)",
      "{",
      "    $0",
      "}"
    ]
  },
  "trav": {
    "prefix": "trav",
    "description": "traverse a container",
    "body": [
      "for (${3:const }auto& ${1:nxt}: ${2:adj[node]})",
      "{",
      "    ${0}",
      "}"
    ]
  },
  "Index Compression": {
    "prefix": "Index Compression",
    "description": "Index Compression",
    "body": [
      "sort(all(av));",
      "vector<int> uv(av.begin(), unique(all(av)));",
      "auto compress = [&](int num) -> int ",
      "{",
      "    return lower_bound(all(uv), num) - uv.begin() + 1;",
      "};"
    ]
  },
  "Static Sum": {
    "prefix": "Static Sum",
    "description": "Prefix Sum",
    "body": [
      "struct prefix_sum",
      "{",
      "    int n;",
      "    vector<int> prefix;",
      "",
      "    prefix_sum()",
      "    {",
      "    }",
      "",
      "    prefix_sum(vector<int> arr)",
      "    {",
      "        n = arr.size();",
      "        prefix.resize(n);",
      "        partial_sum(all(arr), prefix.begin());",
      "    }",
      "",
      "    int query(int l, int r)",
      "    {",
      "        return prefix[r] - ((l != 0) ? prefix[l - 1] : 0);",
      "    }",
      "};"
    ]
  },
  "Centroid Decomposition": {
    "prefix": "Decomposition Centroid ",
    "description": "Centroid Decomposition of Tree",
    "body": [
      "struct centroid_decomposition",
      "{",
      "    // centroid tree data",
      "    int root;",
      "    vector<vector<int>> tree;",
      "    vector<int> parent;",
      "",
      "    // original tree data",
      "    vector<vector<int>> og_tree;",
      "    vector<int> sz;",
      "    vector<bool> vis;",
      "",
      "    centroid_decomposition(vector<vector<int>> &adj)",
      "    {",
      "        int n = adj.size();",
      "        og_tree = adj;",
      "        tree.resize(n);",
      "        parent.resize(n);",
      "        sz.resize(n);",
      "        vis.resize(n);",
      "",
      "        build(1, 0);",
      "    }",
      "",
      "    int dfs_size(int node, int par)",
      "    {",
      "        sz[node] = 1;",
      "        for (const auto &nxt : og_tree[node])",
      "        {",
      "            if (nxt != par && !vis[nxt])",
      "            {",
      "                sz[node] += dfs_size(nxt, node);",
      "            }",
      "        }",
      "        return sz[node];",
      "    }",
      "",
      "    int get_centroid(int node, int par, int max_sz)",
      "    {",
      "        for (const auto &nxt : og_tree[node])",
      "        {",
      "            if (!vis[nxt] && nxt != par && sz[nxt] > max_sz / 2)",
      "            {",
      "                return get_centroid(nxt, node, max_sz);",
      "            }",
      "        }",
      "        return node;",
      "    }",
      "",
      "    void build(int node, int par)",
      "    {",
      "        dfs_size(node, par);",
      "        int centroid = get_centroid(node, par, sz[node]);",
      "        vis[centroid] = 1;",
      "",
      "        parent[centroid] = par;",
      "        if (par != 0)",
      "        {",
      "            tree[centroid].push_back(par);",
      "            tree[par].push_back(centroid);",
      "        }",
      "        else",
      "        {",
      "            root = centroid;",
      "        }",
      "",
      "        for (const auto &nxt : og_tree[centroid])",
      "        {",
      "            if (!vis[nxt])",
      "            {",
      "                build(nxt, centroid);",
      "            }",
      "        }",
      "    }",
      "};"
    ]
  },
  "Euler Totient": {
    "prefix": "Euler Totient",
    "description": "precompute euler totient function",
    "body": [
      "const int MAX_LIMIT = 1e6;",
      "vector<int> primes;",
      "bool isPrime[MAX_LIMIT + 1];",
      "int phi[MAX_LIMIT + 1];",
      "",
      "void totient()",
      "{",
      "    memset(isPrime, true, sizeof(isPrime));",
      "    memset(phi, -1, sizeof(phi));",
      "    isPrime[1] = false;",
      "    phi[1] = 1;",
      "    primes.reserve((MAX_LIMIT + 10) / 10);",
      "    for (int i = 2; i <= MAX_LIMIT; i++)",
      "    {",
      "        if (isPrime[i])",
      "        {",
      "            phi[i] = i - 1;",
      "            primes.push_back(i);",
      "        }",
      "        for (int j = 0; j < (int)primes.size() && i * primes[j] <= MAX_LIMIT; j++)",
      "        {",
      "            isPrime[i * primes[j]] = false;",
      "            if (i % primes[j] != 0)",
      "            {",
      "                phi[i * primes[j]] = phi[i] * phi[primes[j]];",
      "            }",
      "            else",
      "            {",
      "                phi[i * primes[j]] = primes[j] * phi[i];",
      "                break;",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "Walk on SegTree": {
    "prefix": "Walk on SegTree",
    "description": "",
    "body": [
      "struct segment_tree",
      "{",
      "    int n;",
      "    int def_val;",
      "    vector<int> tree;",
      "",
      "    inline int merge_nodes(int left, int right)",
      "    {",
      "        return max(left, right);",
      "    }",
      "",
      "    inline int check(int node, int val)",
      "    {",
      "        return (tree[node] >= val);",
      "    }",
      "",
      "    segment_tree()",
      "    {",
      "        // Empty Constructor",
      "    }",
      "",
      "    segment_tree(int len, int val)",
      "    {",
      "        n = (1LL << (int)(ceill(log2(len))));",
      "        def_val = val;",
      "",
      "        tree.resize(n << 1, def_val);",
      "    }",
      "",
      "    segment_tree(vector<int> &elements, int val)",
      "    {",
      "        n = (1 << (int)(ceill(log2((int)elements.size()))));",
      "        def_val = val;",
      "",
      "        tree.resize(n << 1, def_val);",
      "        for (int i = 0; i < (int)elements.size(); i++)",
      "        {",
      "            tree[n + i] = elements[i];",
      "        }",
      "",
      "        build_inner(1);",
      "    }",
      "",
      "    int query(int l, int r)",
      "    {",
      "        return query_inner(1, l, r, 0, n - 1);",
      "    }",
      "",
      "    void update(int pos, int val)",
      "    {",
      "        tree[n + pos] = val;",
      "        update_inner((n + pos) >> 1);",
      "    }",
      "",
      "    pair<int, int> walk(int l, int r, int x)",
      "    {",
      "        return walk_inner(1, 0, n - 1, l, r, x);",
      "    }",
      "",
      "private:",
      "    pair<int, int> walk_inner(int current_node, int node_l, int node_r, int query_l, int query_r, int val)",
      "    {",
      "        if (node_r < query_l || query_r < node_l)",
      "        {",
      "            return {0, -1};",
      "        }",
      "        else if (node_l == node_r)",
      "        {",
      "            if (check(current_node, val))",
      "            {",
      "                return {1, current_node - n};",
      "            }",
      "            else",
      "            {",
      "                return {0, -1};",
      "            }",
      "        }",
      "        else",
      "        {",
      "            if (!check(current_node, val))",
      "            {",
      "                return {0, -1};",
      "            }",
      "",
      "            int mid = (node_l + node_r) / 2;",
      "            pair<int, int> res = walk_inner((current_node << 1), node_l, mid, query_l, query_r, val);",
      "            if (res.first)",
      "            {",
      "                return res;",
      "            }",
      "            res = walk_inner((current_node << 1) + 1, mid + 1, node_r, query_l, query_r, val);",
      "            return res;",
      "        }",
      "    }",
      "",
      "    int build_inner(int current_node)",
      "    {",
      "        if (current_node >= n)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "        tree[current_node] = merge_nodes(build_inner((current_node << 1)), build_inner((current_node << 1) + 1));",
      "        return tree[current_node];",
      "    }",
      "",
      "    void update_inner(int current_node)",
      "    {",
      "        if (current_node == 0)",
      "        {",
      "            return;",
      "        }",
      "",
      "        tree[current_node] = merge_nodes(tree[(current_node << 1)], tree[(current_node << 1) + 1]);",
      "        update_inner((current_node >> 1));",
      "    }",
      "",
      "    int query_inner(int current_node, int query_l, int query_r, int tree_l, int tree_r)",
      "    {",
      "        if (query_l <= tree_l && tree_r <= query_r)",
      "        {",
      "            return tree[current_node];",
      "        }",
      "",
      "        if (query_l > tree_r || query_r < tree_l)",
      "        {",
      "            return def_val;",
      "        }",
      "",
      "        int mid = ((tree_l + tree_r) >> 1);",
      "        return merge_nodes(query_inner((current_node << 1), query_l, query_r, tree_l, mid), query_inner((current_node << 1) + 1, query_l, query_r, mid + 1, tree_r));",
      "    }",
      "};"
    ]
  },
  "basic": {
    "prefix": "basic",
    "description": "",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "using namespace std;",
      "",
      "using big = long long;",
      "const char nl = '\\n';",
      "",
      "int main()",
      "{",
      "    return 0;",
      "}"
    ]
  }
}
